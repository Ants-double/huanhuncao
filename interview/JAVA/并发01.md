## 1. 概念
- 并发：能够**交替**执行不同的任务。（当系统只有一个CPU时的多线程情况，并发==间隔发生)
- 高并发：能够同时**并行**处理很多请求（多用在互联网分布式系统架构中）
- 并行：两个及以上的任务**同时**执行（要求CPU肯定是两个及以上，原因你懂得！）
## 2. 多线程
- 定义独立任务：只需要实现Runnable接口并编写run（）方法
- 定义有返回值的任务：只需要实现Callable接口并编写call()方法，并且必需使用ExecutorService.submit()调用开启任务  

| 方法 | 内容 | 注意 |
| --- | --- | --- |
|submit|产生一个Future对象|| 
|isDone()|查询Future是否已经完成||
|get()|拿到查询结果|如果不用isDone（）检测直接用get()，将会阻塞直到任务完成也就是有结果可以返回，当然可以用超时get()来处理|  

tips:任务通常会是一种循环形式，任务不会产生线程，是由任务的发起者来决定的是不是建立任务单独线程上下文
### - Thread类
- 作用：它可以以新的线程来驱动任务，通过把任务传递给Thread的构造，并调用Start()方法
- tips:不是的jdk现象不一致，不同机器和运行时间也不一致，异常不能夸线程传播到main() 
- tips:  

| 方法 | 内容 | 注意 |
| --- | --- | --- |
|yield()|暗示线程我活干的差不多了，你可以找下一个来使用CPU了|暗示不一定会采纳，所以控制流程不能依赖于这个方法|
|TimeUnit.MILLISECONDS.sleep()|指定sleep的时间，可读性高||
|sleep()|指定sleep的时间|之前经常见，现在不建议用|
|join()|等任务完成，也就是isAlive()返回false时|可以加一个超时参数，也可以用interrupt()来中断要加try catch哟|  
- 可以直接继承Thread一定要实现线程
### - Executor
- 作用：主要是Thread类对异步的可操作性太差，所以用Executor可以管理异步执行的任务，像
当于在任务和和调用着之间添加了一个中间层（可也以理解为一个命令设计）  

| 方法 | 内容 | 注意 |
| --- | --- | --- |
|CachedThreadPool|将为每个任务创建一个线程|占用很多资源，只有线程池中有可用的时候，才不会创建新的|
|FixedThreadPool|创建有限个线程来执行任务|节省资源，会慢|
|SingThreadExecutor|创建一个线程来执行任务|多用于长时间运行|  
  
### - 优先级  
- 概念：就是说明那个重要那个不重要，与操作系统相关，因为不同的系统有不同的调度有短任务优先还有先来先服务还有分级执行等等吧
tips:考虑可移植性最好只设三个级别 MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY

### - 后台线程  
- 概念：在后台提供服务的线程，所以它不能到前台，所以可以没有它，所以前台的死了它也要陪葬（正在干活的也要马上over)，同样后台线程的子子孙孙注定也只能是个后台线程  

tips:**必须在线程启动前调用setDaemon()来设置后台线程**  

### - 同步
- synchronized 
1. 不会尝试去获取锁，或者尝试进行一段时间的尝试，异常也不能自己定义处理，一但尝试获取又拿不到就阻塞，等着可以拿到，死等，一根筋
- lock  ReentrantLock
1. 在try中有返回值，在finally中调用unlock(),这样可以保证数据的安全
2. 可以尝试获取指定时间和次数的锁，然后决定离开去做其它事
### - 原子性 可视性
- long double 不是原子操作，64位是进行了两次32位的操作
- ++ -- 递增减也不是原子操作
- volatile 
  
    1. 不做任何优化
    2. 可视性就是一但修改，所有的地方都可以知道拿到最新的值
    3. 更改依赖于之前的值时，就无法实现原子性了
- AtomicInteger,AtomicLong,AtomicReference 硬件级别的原子操作

### - 本地线程
- ThreadLocal 
1. 概念：就是每个线程都独立的拥有一份自己的变量，分别存储。但是通常做为静态存取区域 get()返回相关的对象副本，set()将参数插入到线程对象中
 
