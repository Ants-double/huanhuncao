## 设计总纲

``` wi
SOLID
主要是达到高内聚低耦合，并且重点是随着业务的发展也要保持可维护性，可复用性，可拓展性
```



1. **单一职责原则(single responsibility principle)**

   ``` wiki
   一个类只负责一个功能领域中相应的职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
   ```

   

   - 这是最难坚持的，前期容易后期可能随着进度和工期很难坚持。必需要有郭靖那种精神
   
2. **里氏替换原则 (LSP liskov subtitution principle)**

   ``` wik
   所有引用基类（父类）的地方必须能透明地使用其子类的对象
   ```

   - 子类的所有方法必须在父类中声明
   - 尽量把父类设计为抽象类或者接口
   - 里氏代换原则是实现开闭原则的重要方式之一

3. **依赖倒置原则(dependence inversion principle)**

   ``` wiki
   抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程
   ```

   - 参数传递中尽量使用高层次的接口
   - 一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法
   - 两个对象发生依赖关系可以考虑依赖注入
     * 构造注入 通过构造函数来传入具体类的对象
     * 设值注入 通过Setter方法来传入具体类的对象
     * 接口注入 接口中声明的业务方法来传入具体类的对象

4. **接口隔离原则(interface segregation principle)**

   ``` wiki
   使用多个专门的接口，而不使用单一的总接口。即 客户端不应该依赖于那些它不需要的接口
   ```

   - 不要创建大而全的接口。很多程序员偷下懒随手就加上了。不要如此
   
5. **迪米特原则(law of demeter LOD)**

   ``` wi
   一个软件实体应当尽可能少地与其他实体发生相互作用
   ```

   - 开发中多个模块尽量不要直接引用，可以通过通信的方式进行交互
   - 也可以通过第三者代理之类完成交互，不要直接引用。

6. **开闭原则(open closed principle)**

   ``` wi
   一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行 扩展
   ```

   - **抽象化是开闭原则的关键**

   - 尽量达到只需要增加新类就可以实现新的业务功能，不修改已有代码

     



